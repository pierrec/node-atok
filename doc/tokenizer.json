[
  {
    "tags": [],
    "description": {
      "full": "<p>Atok - stream based tokenizer<br />Copyright (c) 2012 Pierre Curto<br />MIT Licensed</p>",
      "summary": "<p>Atok - stream based tokenizer<br />Copyright (c) 2012 Pierre Curto<br />MIT Licensed</p>",
      "body": ""
    },
    "ignore": false,
    "code": "var assert = require('assert')\n  , Stream = require('stream')\n  , EV = require('ev')\n  , sliceArguments = require('fnutils').slice\n  , StringDecoder = require('string_decoder').StringDecoder\n\n\n// Augment the Buffer object with new useful methods\nvar buffertools = require('buffertools')\n\nvar inherits = require('inherits')\n\nvar Rule = require('./rule')",
    "ctx": {
      "type": "declaration",
      "name": "assert",
      "value": "require('assert')",
      "string": "assert"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Expose the atok constructor</p>",
      "summary": "<p>Expose the atok constructor</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = Atok",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Atok",
      "string": "module.exports"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Export atok default events</p>",
      "summary": "<p>Export atok default events</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Atok.events = {\n  // Standard Stream events\n  data: 3\n, end: 3\n, drain: 0\n, open: 1\n, close: 1\n, listening: 0\n, pipe: 1\n// Atok specific events\n, debug: 3\n, empty: 1\n}",
    "ctx": {
      "type": "property",
      "receiver": "Atok",
      "name": "events",
      "value": "{",
      "string": "Atok.events"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Export atok version</p>",
      "summary": "<p>Export atok version</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Atok.version = require('../package.json').version",
    "ctx": {
      "type": "property",
      "receiver": "Atok",
      "name": "version",
      "value": "require('../package.json').version",
      "string": "Atok.version"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object="
        ],
        "name": "atok",
        "description": "stream options"
      },
      {
        "type": "constructor",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>An atok stream</p>",
      "summary": "<p>An atok stream</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Atok (options) {\n  if (!(this instanceof Atok))\n    return new Atok(options)\n\n  // Possible events are defined at instanciation for better performance\n  EV.call(this, Atok.events)\n  this.writable = true\n  this.readable = true\n\n  // Options\n  options = options || {}\n  this._encoding = null\n  if (options.encoding) this.setEncoding( options.encoding )\n\n  // Initializations\n  // Debug flag\n  this.debugMode = false\n\n  // Status flags\n  this.ended = false        // Flag indicating stream has ended\n  this.ending = false       // Set when end() invokes write()\n  this.paused = false       // Flag indicating stream is paused\n  this.needDrain = false    // Flag indicating stream needs drain\n\n// include(\"Atok_properties.js\")\n  // Public properties\n  this.buffer = null\n  this.length = 0\n  this.offset = 0\n  this.markedOffset = -1    // Flag indicating whether the buffer should be kept when write() ends\n\n  // Private properties\n  this._firstRule = null        // Initial rule to be triggered\n  this._resetRule = false       // Rule set was changed\n  this._stringDecoder = this._encoding ? new StringDecoder(this._encoding) : null\n  this._rulesToResolve = false  // Rules need to be resolved (continue() prop)\n  this._rulesToLink = false     // Rules need to be relinked (after a rule set change)\n  this._group = -1\n  this._groupStart = 0\n  this._groupEnd = 0\n  this._groupStartPrev = []\n\n\n    this._rules = []              // Rules to be checked against\n    this._defaultHandler = null   // Matched token default handler\n    this._savedRules = {}         // Saved rules\n\n// include(\"Atok_rule_properties.js\")\n  this._p_ignore = false        // Get the token size and skip\n  this._p_quiet = false         // Get the token size and call the handler with no data\n  this._p_escape = false        // Pattern must not be escaped\n  this._p_trimLeft = true       // Remove the left pattern from the token\n  this._p_trimRight = true      // Remove the right pattern from the token\n  this._p_next = null           // Next rule to load\n  this._p_nextIndex = 0         // Index for the next rule to load\n  this._p_continue = null       // Next rule index to load\n  this._p_continueOnFail = null // Next rule index to load when rule fails\n  this._p_break = false         // Abort current rule set\n\n  this._defaultProps = Object.keys(this)\n    .filter(function (prop) {\n      return /^_p_/.test(prop) && !/(continueOnFail|nextIndex)$/.test(prop)\n    })\n    .map(function (prop) {\n      return prop.substr(3)\n    })\n}\ninherits(Atok, EV, Stream.prototype)\n\n// Atok.prototype.__defineGetter__('currentRule', function () {\n//   return this._firstRule ? this._firstRule.currentRule : null\n// })\n\nAtok.prototype._error = function (err) {\n  this.readable = false\n  this.writable = false\n\n  this.emit_error(err)\n\n  return this\n}\n\n// include(\"methods_misc.js\")",
    "ctx": {
      "type": "function",
      "name": "Atok",
      "string": "Atok()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean"
        ],
        "name": "keep",
        "description": "rules set (default=false)"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Reset the tokenizer by clearing its buffer and rules</p>",
      "summary": "<p>Reset the tokenizer by clearing its buffer and rules</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.clear = function (keepRules) {\n// include(\"Atok_properties.js\")\n  // Public properties\n  this.buffer = null\n  this.length = 0\n  this.offset = 0\n  this.markedOffset = -1    // Flag indicating whether the buffer should be kept when write() ends\n\n  // Private properties\n  this._firstRule = null        // Initial rule to be triggered\n  this._resetRule = false       // Rule set was changed\n  this._stringDecoder = this._encoding ? new StringDecoder(this._encoding) : null\n  this._rulesToResolve = false  // Rules need to be resolved (continue() prop)\n  this._rulesToLink = false     // Rules need to be relinked (after a rule set change)\n  this._group = -1\n  this._groupStart = 0\n  this._groupEnd = 0\n  this._groupStartPrev = []\n\n\n  if (!keepRules) {\n\n    this._rules = []              // Rules to be checked against\n    this._defaultHandler = null   // Matched token default handler\n    this._savedRules = {}         // Saved rules\n\n  }\n\n  this.clearProps()\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "clear",
      "string": "Atok.prototype.clear()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "starting",
        "description": "index"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "ending",
        "description": "index"
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "extracted data"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Extract data from the buffer (Atok#slice)</p>",
      "summary": "<p>Extract data from the buffer (Atok#slice)</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.slice = function (start, end) {\n  return this.buffer.slice(start, end)\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "slice",
      "string": "Atok.prototype.slice()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "left over data"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Terminate the current tokenizing and return the current buffer</p>",
      "summary": "<p>Terminate the current tokenizing and return the current buffer</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.flush = function () {\n  var data = this.slice()\n  \n  this.clear(true) // Keep rules!\n\n  return data\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "flush",
      "string": "Atok.prototype.flush()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "encoding",
        "description": "to be used"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Set the string encoding</p>",
      "summary": "<p>Set the string encoding</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.setEncoding = function (enc) {\n  switch ( String(enc) ) {\n    case 'null':\n    case 'undefined':\n      this._encoding = null\n    break\n    case 'UTF-8':\n    case 'utf-8':\n    case 'utf8':\n    default:\n      this._encoding = 'UTF-8'\n  }\n  this._stringDecoder = this._encoding\n    ? new StringDecoder(this._encoding)\n    : null\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "setEncoding",
      "string": "Atok.prototype.setEncoding()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean"
        ],
        "name": "toggle",
        "description": "debug mode on and off"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Turn debug mode on or off. Emits the [debug] event.<br />The #loadRuleSet method is also put in debug mode.<br />All handlers log their arguments.</p>",
      "summary": "<p>Turn debug mode on or off. Emits the [debug] event.<br />The #loadRuleSet method is also put in debug mode.<br />All handlers log their arguments.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.debug = function (flag) {\n  var _debug = !!flag\n\n  // Nothing to do if already in same mode\n  if (_debug === this.debugMode) return this\n  this.debugMode = _debug\n\n  // Apply debug mode to all defined rules...\n  var self = this\n  this._rulesForEach(function (rule) {\n    rule.setDebug(_debug, self)\n  })\n\n  // Apply debug mode to some methods\n  ;[ 'loadRuleSet' ].forEach(function (method) {\n    if (_debug) {\n      var prevMethod = self[method]\n\n      self[method] = function () {\n        self.emit_debug( 'Atok#', method, arguments )\n        return prevMethod.apply(self, arguments)\n      }\n    } else {\n      // Restore the prototype method\n      delete self[method]\n    }\n  })\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "debug",
      "string": "Atok.prototype.debug()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "function()"
        ],
        "name": "iterator",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Apply an iterator to all current rules</p>",
      "summary": "<p>Apply an iterator to all current rules</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Atok.prototype._rulesForEach = function (fn) {\n  this._rules.forEach(fn)\n\n  var saved = this._savedRules\n  Object.keys(saved).forEach(function (ruleSet) {\n    saved[ruleSet].rules.forEach(fn)\n  })\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_rulesForEach",
      "string": "Atok.prototype._rulesForEach()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "rule set name"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Get the current rule set name</p>",
      "summary": "<p>Get the current rule set name</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.currentRule = function () {\n  return this._firstRule ? this._firstRule.currentRule : null\n}// include(\"methods_ruleprops.js\")",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "currentRule",
      "string": "Atok.prototype.currentRule()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "function(string",
          ""
        ],
        "name": "number,",
        "description": "string|null)} rules handler (it is better to name it for debugging)"
      },
      {
        "type": "",
        "string": "handler is called with (token, index, type)"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Set the default handler.<br />Triggered on all subsequently defined rules if the handler is not supplied</p>",
      "summary": "<p>Set the default handler.<br />Triggered on all subsequently defined rules if the handler is not supplied</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.setDefaultHandler = function (handler) {\n  this._defaultHandler = typeof handler === 'function' ? handler : null\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "setDefaultHandler",
      "string": "Atok.prototype.setDefaultHandler()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "of the rule set to load if rule successful"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "index",
        "description": "to start at"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Skip matched data silently for all subsequent rules</p>",
      "summary": "<p>Skip matched data silently for all subsequent rules</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.next = function (ruleSet, index) {\n  this._p_next = typeof ruleSet === 'string' ? ruleSet : null\n  this._p_nextIndex = typeof index === 'number' ? index : 0\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "next",
      "string": "Atok.prototype.next()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean",
          "undefined"
        ],
        "name": "flag",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Skip matched data silently for all subsequent rules</p>",
      "summary": "<p>Skip matched data silently for all subsequent rules</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.ignore = function (flag) {\n  this._p_ignore = (flag === true)\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "ignore",
      "string": "Atok.prototype.ignore()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean",
          "undefined"
        ],
        "name": "flag",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Do not supply matched data to the handler for all subsequent rules.<br />This is used when the token data does not matter but a handler <br />still needs to be called. Faster than standard handler call.</p>",
      "summary": "<p>Do not supply matched data to the handler for all subsequent rules.<br />This is used when the token data does not matter but a handler <br />still needs to be called. Faster than standard handler call.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.quiet = function (flag) {\n  this._p_quiet = (flag === true)\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "quiet",
      "string": "Atok.prototype.quiet()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean",
          "undefined"
        ],
        "name": "flag",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove the left matched pattern for all subsequent rules</p>",
      "summary": "<p>Remove the left matched pattern for all subsequent rules</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.trimLeft = function (flag) {\n  this._p_trimLeft = (flag === true)\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "trimLeft",
      "string": "Atok.prototype.trimLeft()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean",
          "undefined"
        ],
        "name": "flag",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove the right matched pattern for all subsequent rules<br />If only 1 pattern, it is ignored</p>",
      "summary": "<p>Remove the right matched pattern for all subsequent rules<br />If only 1 pattern, it is ignored</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.trimRight = function (flag) {\n  this._p_trimRight = (flag === true)\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "trimRight",
      "string": "Atok.prototype.trimRight()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean",
          "undefined"
        ],
        "name": "flag",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove the left and right matched patterns for all subsequent rules</p>",
      "summary": "<p>Remove the left and right matched patterns for all subsequent rules</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.trim = function (flag) {\n  return this.trimLeft(flag).trimRight(flag)\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "trim",
      "string": "Atok.prototype.trim()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "boolean",
          "undefined"
        ],
        "name": "flag",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Do not remove the left and right matched patterns for all subsequent rules<br />The default escape character is , can be changed by specifying it instead of a Boolean</p>",
      "summary": "<p>Do not remove the left and right matched patterns for all subsequent rules<br />The default escape character is , can be changed by specifying it instead of a Boolean</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.escape = function (flag) {\n  this._p_escape = flag === true\n    ? '\\\\'\n    : flag && flag.length > 0\n      ? flag.toString(this._encoding || 'utf8').charAt(0)\n      : false\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "escape",
      "string": "Atok.prototype.escape()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "number",
          "null",
          "undefined"
        ],
        "name": "number",
        "description": "of rules to skip before continuing"
      },
      {
        "type": "param",
        "types": [
          "number",
          "null",
          "undefined"
        ],
        "name": "when",
        "description": "the rule fails, number of rules to skip before continuing"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Continue the rules flow if rule matches at the specified rule index</p>",
      "summary": "<p>Continue the rules flow if rule matches at the specified rule index</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.continue = function (jump, jumpOnFail) {\n  if (arguments.length === 0) {\n    this._p_continue = null\n    this._p_continueOnFail = null\n\n    return this\n  }\n\n  if ( jump !== null && !/(number|string|function)/.test(typeof jump) )\n    this._error( new Error('Atok#continue: Invalid jump (must be an integer/function/string): ' + jump) )\n  \n  if (arguments.length === 1)\n    jumpOnFail = null\n  else if ( jumpOnFail !== null && !/(number|string|function)/.test(typeof jumpOnFail) )\n    this._error( new Error('Atok#continue: Invalid jump (must be an integer/function/string): ' + jumpOnFail) )\n  \n  this._p_continue = jump\n  this._p_continueOnFail = jumpOnFail\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "continue",
      "string": "Atok.prototype.continue()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Abort a current rule set. Use continue(-1) to resume at the current subrule.</p>",
      "summary": "<p>Abort a current rule set. Use continue(-1) to resume at the current subrule.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.break = function (flag) {\n  this._p_break = (flag === true)\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "break",
      "string": "Atok.prototype.break()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "properties",
        "description": "to be loaded"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Restore properties</p>",
      "summary": "<p>Restore properties</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.setProps = function (props) {\n  var propNames = Object.keys(props || {})\n\n  for (var prop, i = 0, n = propNames.length; i < n; i++) {\n    prop = propNames[i]\n    if ( this.hasOwnProperty('_p_' + prop) )\n      switch (prop) {\n        // Special case: continue has 2 properties\n        case 'continue':\n          this._p_continue = props[ prop ][0]\n          this._p_continueOnFail = props[ prop ][1]\n        break\n        // Special case: next has 2 properties\n        case 'next':\n          this._p_next = props[ prop ][0]\n          this._p_nextIndex = props[ prop ][1]\n        break\n        default:\n          this[ '_p_' + prop ] = props[ prop ]\n      }\n  }\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "setProps",
      "string": "Atok.prototype.setProps()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Reset properties to their default values</p>",
      "summary": "<p>Reset properties to their default values</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.clearProps = function () {\n// include(\"Atok_rule_properties.js\")\n  this._p_ignore = false        // Get the token size and skip\n  this._p_quiet = false         // Get the token size and call the handler with no data\n  this._p_escape = false        // Pattern must not be escaped\n  this._p_trimLeft = true       // Remove the left pattern from the token\n  this._p_trimRight = true      // Remove the right pattern from the token\n  this._p_next = null           // Next rule to load\n  this._p_nextIndex = 0         // Index for the next rule to load\n  this._p_continue = null       // Next rule index to load\n  this._p_continueOnFail = null // Next rule index to load when rule fails\n  this._p_break = false         // Abort current rule set\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "clearProps",
      "string": "Atok.prototype.clearProps()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Reset properties to their default values</p>",
      "summary": "<p>Reset properties to their default values</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.getProps = function () {\n  // Empty object with no prototype\n  var props = Object.create(null)\n  var propNames = arguments.length > 0\n        ? sliceArguments(arguments, 0)\n        : this._defaultProps\n\n  for (var prop, i = 0, num = propNames.length; i < num; i++) {\n    prop = propNames[i]\n    if ( this.hasOwnProperty('_p_' + prop) )\n      switch (prop) {\n        // Special case: continue has 2 properties\n        case 'continue':\n          props[ prop ] = [ this._p_continue, this._p_continueOnFail ]\n        break\n        // Special case: next has 2 properties\n        case 'next':\n          props[ prop ] = [ this._p_next, this._p_nextIndex ]\n        break\n        default:\n          props[ prop ] = this[ '_p_' + prop ]\n      }\n  }\n\n  return props\n}\n// include(\"methods_ruleset.js\")",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "getProps",
      "string": "Atok.prototype.getProps()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "name",
        "description": "of the rule to be added first"
      },
      {
        "type": "param",
        "types": [
          "...string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "item"
      },
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "type"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "see",
        "local": "Atok#addRule",
        "visibility": "Atok#addRule"
      }
    ],
    "description": {
      "full": "<p>Add a rule as the first one</p>",
      "summary": "<p>Add a rule as the first one</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.addRuleFirst = function (rule,",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "addRuleFirst",
      "string": "Atok.prototype.addRuleFirst()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ule, ...</p>",
      "summary": "<p>ule, ...</p>",
      "body": ""
    },
    "ignore": false,
    "code": "type) {\n  this.addRule.apply( this, sliceArguments(arguments, 0) )\n  this._rules.unshift( this._rules.pop() )\n\n  return this\n}"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "type"
      },
      {
        "type": "return",
        "types": [
          "number"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Get the index of a rule by id</p>",
      "summary": "<p>Get the index of a rule by id</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Atok.prototype._getRuleIndex = function (id) {\n  for (var rules = this._rules, i = 0, n = rules.length; i < n; i++)\n    if (rules[i].id === id) return i\n  \n  return -1\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_getRuleIndex",
      "string": "Atok.prototype._getRuleIndex()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "name",
        "description": "of the rule to add before"
      },
      {
        "type": "param",
        "types": [
          "...string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "item"
      },
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "type"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "see",
        "local": "Atok#addRule",
        "visibility": "Atok#addRule"
      }
    ],
    "description": {
      "full": "<p>Add a rule before an existing one</p>",
      "summary": "<p>Add a rule before an existing one</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.addRuleBefore = function (existingRule, rule,",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "addRuleBefore",
      "string": "Atok.prototype.addRuleBefore()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ule, ...</p>",
      "summary": "<p>ule, ...</p>",
      "body": ""
    },
    "ignore": false,
    "code": "type) {\n  var i = this._getRuleIndex(existingRule)\n\n  if ( i < 0 )\n    return this._error( new Error('Atok#addRuleBefore: rule ' + existingRule + ' does not exist') )\n\n  this.addRule.apply( this, sliceArguments(arguments, 1) )\n  this._rules.splice( i, 0, this._rules.pop() )\n\n  return this\n}"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "name",
        "description": "of the rule to add after"
      },
      {
        "type": "param",
        "types": [
          "...string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "item"
      },
      {
        "type": "param",
        "types": [
          "string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "type"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "see",
        "local": "Atok#addRule",
        "visibility": "Atok#addRule"
      }
    ],
    "description": {
      "full": "<p>Add a rule after an existing one</p>",
      "summary": "<p>Add a rule after an existing one</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.addRuleAfter = function (existingRule, rule,",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "addRuleAfter",
      "string": "Atok.prototype.addRuleAfter()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ule, ...</p>",
      "summary": "<p>ule, ...</p>",
      "body": ""
    },
    "ignore": false,
    "code": "type) {\n  var i = this._getRuleIndex(existingRule)\n\n  if ( i < 0 )\n    return this._error( new Error('Atok#addRuleAfter: rule ' + existingRule + ' does not exist') )\n\n  this.addRule.apply( this, sliceArguments(arguments, 1) )\n  this._rules.splice( i + 1, 0, this._rules.pop() )\n\n  return this\n}"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "...string",
          "number",
          "function()"
        ],
        "name": "match",
        "description": "at current buffer position (String: expect string, Integer: expect n characters, Array: expect one of the items). If not needed, use ''"
      },
      {
        "type": "param",
        "types": [
          "false",
          "string",
          "number",
          "function()"
        ],
        "name": "rule",
        "description": "name/id (if no default handler set, emit a data event) or handler (executed when all matches are valid). If false, the rule is ignored."
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Add a rule</p>",
      "summary": "<p>Add a rule</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.addRule = function (",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "addRule",
      "string": "Atok.prototype.addRule()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ule1, rule2, ... type|handler</p>",
      "summary": "<p>ule1, rule2, ... type|handler</p>",
      "body": ""
    },
    "ignore": false,
    "code": "{\n  var args = sliceArguments(arguments, 0)\n\n  if (args.length < 1) {\n    this._error( new Error('Atok#addRule: Missing arguments ("
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ule1, rule2 ...</p>",
      "summary": "<p>ule1, rule2 ...</p>",
      "body": ""
    },
    "ignore": false,
    "code": "type|handler)') )\n    return this\n  }\n\n  var last = args.pop()\n\n  // Ignore the rule if the handler/type is false\n  if (last === false) return this\n\n  var first = args[0]\n  var type = null\n    , handler = this._defaultHandler\n\n  switch ( typeof(last) ) {\n    case 'function':\n      handler = last\n      break\n    case 'number':\n    case 'string':\n      type = last\n      break\n    default:\n      this._error( new Error('Atok#addRule: invalid type/handler, must be Number/String/Function') )\n      return this\n  }\n\n  if ( first === 0 )\n    this._error( new Error('Atok#addRule: invalid first subrule, must be > 0') )\n  else {\n    var groupProps = Object.create(null)\n    groupProps.group = this._group\n    groupProps.groupStart = this._groupStart\n    groupProps.groupEnd = this._groupEnd\n    this._rules.push(\n      new Rule(\n        args\n      , type\n      , handler\n      , this.getProps()\n      , groupProps\n      , this._encoding\n      )\n    )\n  }\n\n  this._rulesToResolve = true\n\n  return this\n}"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "of the rule to be removed"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove a rule (first instance only)</p>",
      "summary": "<p>Remove a rule (first instance only)</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.removeRule = function (",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "removeRule",
      "string": "Atok.prototype.removeRule()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>name ...</p>",
      "summary": "<p>name ...</p>",
      "body": ""
    },
    "ignore": false,
    "code": "{\n  if (arguments.length === 0) return this\n  \n  for (var idx, i = 0, n = arguments.length; i < n; i++) {\n    idx = this._getRuleIndex(arguments[i])\n    if (idx >= 0) {\n      this._rules.splice(idx, 1)\n    }\n  }\n  this._rulesToResolve = true\n\n  return this\n}"
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove all rules</p>",
      "summary": "<p>Remove all rules</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.clearRule = function () {\n  this.clearProps()\n  this._firstRule = null\n  this._rules = []\n  this._defaultHandler = null\n  this._rulesToResolve = false\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "clearRule",
      "string": "Atok.prototype.clearRule()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "of the rule set"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Save all rules and clear them</p>",
      "summary": "<p>Save all rules and clear them</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.saveRuleSet = function (name) {\n  if (arguments.length === 0 || name === null)\n    return this._error( new Error('Atok#saveRuleSet: invalid rule name supplied') )\n\n  this._savedRules[name] = {\n    rules: this._rules\n      .map(function (rule) {    // Clone and assign the current rule set name\n        return rule.clone(name)\n      })\n  }\n\n  // Resolve and check continues\n  this._resolveRules(name)\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "saveRuleSet",
      "string": "Atok.prototype.saveRuleSet()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "of the rule set"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "index",
        "description": "to start at"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Load a rule set</p>",
      "summary": "<p>Load a rule set</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.loadRuleSet = function (name, index) {\n  var ruleSet = this._savedRules[name]\n  if (!ruleSet)\n    return this._error( new Error('Atok#loadRuleSet: Rule set ' + name + ' not found') )\n\n  index = typeof index === 'number' ? index : 0\n\n  this._rules = ruleSet.rules\n  // Set the rule index\n  this._firstRule = this._rules[index]\n  this._resetRule = true\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "loadRuleSet",
      "string": "Atok.prototype.loadRuleSet()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "of the rule set"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Delete a rule set</p>",
      "summary": "<p>Delete a rule set</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.removeRuleSet = function (name) {\n  delete this._savedRules[name]\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "removeRuleSet",
      "string": "Atok.prototype.removeRuleSet()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "of the rule set (optional)"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<h2>Resolve a rule or all of them if none specified</h2>\n\n<ul>\n<li>translate non number continue() to numbers</li>\n<li>check continue() stay within bounds</li>\n<li>adjust the continue() jumps based on groups</li>\n</ul>\n\n<p>Also detects infinite loops<br />Rules are linked if no name supplied</p>",
      "summary": "<h2>Resolve a rule or all of them if none specified</h2>\n\n<ul>\n<li>translate non number continue() to numbers</li>\n<li>check continue() stay within bounds</li>\n<li>adjust the continue() jumps based on groups</li>\n</ul>",
      "body": "<p>Also detects infinite loops<br />Rules are linked if no name supplied</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Atok.prototype._resolveRules = function (name) {\n  var self = this\n  // Check and set the continue values\n  var rules = name ? this._savedRules[name].rules : this._rules\n\n  function getErrorData (i) {\n    return ( self.currentRule() ? '@' + self.currentRule() : ' ' )\n      + (arguments.length > 0\n          ? '[' + i + ']'\n          : ''\n        )\n  }\n\n  // Perform various checks on a continue type property\n  function resolveId (prop) {\n    if (rule[prop] === null || typeof rule[prop] === 'number') return\n\n    // Resolve the property to an index\n    var j = self._getRuleIndex(rule.id)\n    if (j < 0)\n      self._error( new Error('Atok#_resolveRules: ' + prop + '() value not found: ' + rule.id) )\n      \n    rule[prop] = i - j\n  }\n\n  // prop: continue type\n  // idx: continue type index\n  function checkContinue (prop, idx) {\n    if (typeof rule[prop] !== 'number') return\n\n    // incr: 1 or -1 (positive/negative continue)\n    // offset: 0 or 1 (positive/negative continue)\n    function setContinue (incr, offset) {\n      // j = current index to be checked\n      // count = number of indexes to check\n      for (\n        var j = i + incr, count = 0, m = Math.abs(cont + offset)\n      ; count < m\n      ; j += incr, count++\n      ) {\n        // Scan all rules from the current one to the target one\n        var _rule = rules[j]\n\n        // Jumping to the last rule is valid\n        if (j === n && count === m - 1) return\n\n        if (j < 0 || j >= n)\n          self._error( new Error('Atok#_resolveRules: ' + prop + '() value out of bounds: ' + cont + getErrorData(i)) )\n\n        // Only process rules bound to a group below the current one\n        // Or at the same level but different\n        if (_rule.group > rule.group\n        || (_rule.group === rule.group && _rule.groupStart !== rule.groupStart)\n        ) {\n          // Get to the right group\n          while (_rule.group > rule.group + 1) {\n            j = incr > 0 ? _rule.groupEnd + 1 : _rule.groupStart - 1\n            // Jump to the end of the rules is ignored\n            if (j > n) {\n              cont = null\n              return\n            }\n\n            _rule = rules[j]\n          }\n          j = incr > 0 ? _rule.groupEnd : _rule.groupStart\n          cont += incr * (_rule.groupEnd - _rule.groupStart)\n        }\n      }\n    }\n\n    // Use the backup value\n    var cont = rule.props.continue[idx]\n\n    // continue(0) and continue(-1) do not need any update\n    if (cont > 0)\n      // Positive jump\n      setContinue(1, 0)\n    else if (cont < -1)\n      // Negative jump\n      setContinue(-1, 1)\n    \n    // Check the continue boundaries\n    var j = i + cont + 1\n    // Cannot jump to a rule before the first one or beyond the last one.\n    // NB. jumping to a rule right after the last one is accepted since\n    // it will simply stop the parsing\n    if (j < 0 || j > n)\n      self._error( new Error('Atok#_resolveRules: ' + prop + '() value out of bounds: ' + cont + getErrorData(i)) )\n\n    // Save the next rule index\n    rule[prop] = cont\n  }\n\n  // Process all rules\n  // Adjust continue jumps according to groups\n  for (var i = 0, n = rules.length; i < n; i++) {\n    var rule = rules[i]\n    // Check each rule continue property\n    checkContinue('continue', 0)\n    checkContinue('continueOnFail', 1)\n\n    // Set values for null\n    if (rule.continue === null)\n      // Go to the start of the rule set\n      rule.continue = -(i + 1)\n\n    if (rule.continueOnFail === null)\n      // Go to the next rule\n      rule.continueOnFail = 0\n\n    // Check the continue property\n    resolveId('continue')\n\n    // Check the continueOnFail property\n    resolveId('continueOnFail')\n\n    // Check the group is terminated\n    if (rule.group >= 0 && rule.groupEnd === 0)\n      this._error( new Error('Atok#_resolveRules: non terminated group starting at index ' + rule.groupStart ) )\n\n  }\n\n  // Infinite loop detection\n  // An infinite loop is created when:\n  // - a 0 length rule points to another 0 length one\n  // - linked continueOnFails create a loop\n  for (var i = 0, n = rules.length; i < n; i++) {\n    var rule = rules[i]\n\n    // Zero length rules\n\n    if ( rule.length === 0\n      && (n === 1\n        || (\n          // continue may point to the end of the list\n              i + 1 + rule.continue < n\n          && rules[ i + 1 + rule.continue ].length === 0\n          // continueOnFail may point to the end of the list\n          && i + 1 + rule.continueOnFail < n\n          && rules[ i + 1 + rule.continueOnFail ].length === 0\n          )\n        )\n      )\n        this._error( new Error('Atok#_resolveRules: zero-length rules infinite loop' + getErrorData(i)) )\n\n    // Looped failures\n    var failList = []\n    for (var j = i; j > -1 && j < n; j += rules[j].continueOnFail + 1) {\n      if ( failList.indexOf(j) >= 0 )\n        this._error( new Error('Atok#_resolveRules: infinite loop' + getErrorData(i)) )\n\n      failList.push(j)\n    }\n  }\n\n  // Resolution successfully completed\n  this._rulesToResolve = false\n\n  // Rules need to be relinked:\n  // - Delay if rules resolution was called in a saveRuleSet(name)\n  // - Link immediately otherwise\n  if (name) this._rulesToLink = true\n  else this._linkRules()\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_resolveRules",
      "string": "Atok.prototype._resolveRules()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "toggle",
        "description": "grouping on/off"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Bind rules to the same index</p>",
      "summary": "<p>Bind rules to the same index</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.groupRule = function (flag) {\n  var rules = this._rules\n\n  if (flag) {\n    this._group++\n    this._groupStartPrev.push(this._groupStart)\n    this._groupStart = rules.length\n\n    return this\n  }\n\n  // Ignore invalid groupRule()\n  if (this._group < 0) return this\n  \n  // 1 or 0 rule within the group, ignored it\n  if (rules.length - this._groupStart < 2) {\n    for (var i = this._groupStart, n = rules.length; i < n; i++) {\n      rules[i].group = -1\n      rules[i].groupStart = 0\n      rules[i].groupEnd = 0\n    }\n  } else {\n    // Set the last index of the group to all rules belonging to the current group\n    for (var i = this._groupStart, n = rules.length; i < n; i++)\n      if (rules[i].group === this._group)\n        rules[i].groupEnd = n - 1\n  }\n\n  this._group--\n  this._groupStart = this._groupStartPrev.pop() || 0\n  this._groupEnd = 0\n\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "groupRule",
      "string": "Atok.prototype.groupRule()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Link rules</p>",
      "summary": "<p>Link rules</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Atok.prototype._linkRules = function () {\n  var self = this\n  var _savedRules = this._savedRules\n  var rules = this._rules\n\n  if (this._rules.length === 0)\n    this._error( new Error('Atok#_linkRules: no rule defined') )\n\n  link(rules)\n  Object.keys(_savedRules)\n    .forEach(function (k) {\n      link( _savedRules[k].rules )\n  })\n\n  // Rules entry point\n  this._firstRule = rules[0]\n\n  // Rules are now linked\n  this._rulesToLink = false\n\n  function getRuleFromSet (arr) {\n    var ruleSet = arr[0]\n    var rule = _savedRules[ ruleSet ]\n    if (!rule)\n        self._error( new Error('Atok#_linkRules: missing rule set: ' + ruleSet ) )\n\n    return _savedRules[ ruleSet ].rules[ arr[1] ]\n  }\n\n  function link (rules) {\n    // Link rules\n    for (var i = 0, n = rules.length; i < n; i++) {\n      var rule = rules[i]\n      var props = rule.props\n      var next = props.next\n\n      // On rule success\n      rule.next =  next[0]\n        ? getRuleFromSet(next)\n        : ( rules[ i + rule.continue + 1 ] || null )\n\n      // On rule failure\n      rule.nextFail = rules[ i + rule.continueOnFail + 1 ] || null\n    }\n  }\n}\n// include(\"methods_stream.js\")",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_linkRules",
      "string": "Atok.prototype._linkRules()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string",
          "Buffer"
        ],
        "name": "data",
        "description": "to be processed"
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "whether `Atok#write()` can be called again"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Applies the current rules to the incoming data.<br />When false is returned (the tokenizer is paused), the data is buffered but<br />no processing occurs until the tokenizer is resumed.</p>",
      "summary": "<p>Applies the current rules to the incoming data.<br />When false is returned (the tokenizer is paused), the data is buffered but<br />no processing occurs until the tokenizer is resumed.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.write = function (data) {\n  if (this.ended) {\n    this._error( new Error('Atok#write: write after end') )\n    return false\n  }\n\n  if (!data || data.length === 0) return true\n\n  // Setting the encoding by default when receiving a string\n  if ( typeof data === 'string' && !this._encoding ) this.setEncoding('utf-8')\n\n  // Buffer the incoming data...\n  if (this.length > 0) {\n    // Process strings and Buffers separately\n    if ( this._encoding ) {\n      this.buffer += this._stringDecoder.write( data.toString() )\n    } else {\n      this.buffer = this.buffer.concat(data)\n      // this.buffer = Buffer.concat( [ this.buffer, data ], this.length )\n    }\n  } else {\n    this.buffer = this._encoding ? data.toString() : data\n  }\n  this.length = this.buffer.length\n\n  // Check rules resolution (pause __can__ be called before write)\n  if (this._rulesToResolve) this._resolveRules() // Does linking too\n  // No resolution but linking may be required\n  else if (this._rulesToLink) this._linkRules()\n\n  // ... hold on until tokenization completed on the current data set\n  // or consume the data\n  if (this.paused) {\n    this.needDrain = true\n    return false\n  }\n\n  return this._tokenize()\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "write",
      "string": "Atok.prototype.write()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string",
          "Buffer"
        ],
        "name": "data",
        "description": "to be processed"
      },
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Ends the stream and emit the <code>end</code> event. Any remaining data is passed to <br />the listeners.</p>",
      "summary": "<p>Ends the stream and emit the <code>end</code> event. Any remaining data is passed to <br />the listeners.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.end = function (data) {\n  this.ending = true\n  this.write(data)\n  this.ended = true\n  this.ending = false\n\n  this.readable = false\n  this.writable = false\n\n  this._end()\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "end",
      "string": "Atok.prototype.end()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Atok"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Pauses the stream - data is buffered until the <br /> stream is resumed with <code>Atok#resume()</code></p>",
      "summary": "<p>Pauses the stream - data is buffered until the <br /> stream is resumed with <code>Atok#resume()</code></p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.pause = function () {\n  this.paused = true\n  return this\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "pause",
      "string": "Atok.prototype.pause()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "same as `Atok#write()`"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Resumes the stream - buffered data is immediately processed</p>",
      "summary": "<p>Resumes the stream - buffered data is immediately processed</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.resume = function () {\n  this.paused = false\n  return this._tokenize()\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "resume",
      "string": "Atok.prototype.resume()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Placeholder for <code>Atok#destroy()</code></p>",
      "summary": "<p>Placeholder for <code>Atok#destroy()</code></p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype.destroy = function () {\n  this.readable = false\n  this.writable = false\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "destroy",
      "string": "Atok.prototype.destroy()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Private methods</p>",
      "summary": "<p>Private methods</p>",
      "body": ""
    },
    "ignore": false
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>End a stream by emitting the <code>end</code> event with remaining data</p>",
      "summary": "<p>End a stream by emitting the <code>end</code> event with remaining data</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype._end = function () {\n  this.emit_end( this.buffer, -1, this.currentRule )\n  this.clear()\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_end",
      "string": "Atok.prototype._end()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>End of <code>Atok#write()</code>: emit the <code>drain</code> event if required</p>",
      "summary": "<p>End of <code>Atok#write()</code>: emit the <code>drain</code> event if required</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype._done = function () {\n  if (this.needDrain) {\n    this.needDrain = false\n    this.emit_drain()\n  }\n\n  if (this.ended) {\n    this._end()\n    return false\n  }\n\n  return true\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_done",
      "string": "Atok.prototype._done()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>The core of Atok. Loops through the rules and check them against the data,<br />calling handler or emitting the <code>data</code> event and branching appropriately.</p>",
      "summary": "<p>The core of Atok. Loops through the rules and check them against the data,<br />calling handler or emitting the <code>data</code> event and branching appropriately.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Atok.prototype._tokenize = function () {\n  // NB. Rules and buffer can be reset by the token handler\n  var p, props, matched\n  var token\n\n  p = this._firstRule\n  this._resetRule = false\n\n  while ( p && this.offset < this.length ) {\n    props = p.props\n\n    // Return the size of the matched data (0 is valid!)\n    matched = p.test(this.buffer, this.offset)\n\n    if ( matched < 0 ) {\n      // End of the rule set, end the loop\n      if (!p.nextFail) break\n\n      // Next rule exists, carry on\n      p = p.nextFail\n      continue\n    }\n\n    // Is the token to be processed?\n    if ( props.ignore ) {\n      p = p.next\n    } else {\n      // Emit the data by default, unless the handler is set\n      token = props.quiet\n        ? matched - (p.single ? 0 : p.last.length) - p.first.length\n        : this.buffer.slice(\n            this.offset + p.first.length\n          , this.offset + matched - (p.single ? 0 : p.last.length)\n          )\n\n      if (p.handler) p.handler(token, p.last.idx, p.type)\n      else this.emit_data(token, p.last.idx, p.type)\n\n      // Handler has changed rules, resolve and relink\n      if (this._rulesToResolve) this._resolveRules()\n\n      // RuleSet may have be changed by the handler\n      if (this._resetRule) {\n        this._resetRule = false\n        p = this._firstRule\n      } else {\n        p = p.next\n      }\n    }\n\n    this.offset += matched\n\n    // NB. `break()` prevails over `pause()`\n    if (props.break) break\n\n    // Hold on if the stream was paused\n    if (this.paused) {\n      this._firstRule = p\n      this.needDrain = true\n      return false\n    }\n  }\n\n  // Keep track of the rule we are at\n  if (p) this._firstRule = p\n\n  // Truncate the buffer if possible: min(offset, markedOffset)\n  if (this.markedOffset < 0) {\n    // No marked offset or beyond the current offset\n    if (this.offset === this.length) {\n      this.offset = 0\n      this.buffer = null\n      this.length = 0\n      this.emit_empty(this.ending)\n\n    } else if (this.offset < this.length) {\n      this.buffer = this.buffer.slice(this.offset)\n      this.length = this.buffer.length\n      this.offset = 0\n\n    } else {\n      // Can only occurs if offset was manually incremented\n      this.offset = this.offset - this.length\n      this.buffer = null\n      this.length = 0\n    }\n\n  } else {\n    var maxOffset = 'markedOffset'\n    var minOffset = 'offset'\n    var _\n\n    if (this.markedOffset < this.offset) {\n      _ = maxOffset\n      maxOffset = minOffset\n      minOffset = _\n    }\n\n    if (this[minOffset] === this.length) {\n      this[maxOffset] -= this[minOffset]\n      this[minOffset] = 0\n      this.buffer = null\n      this.length = 0\n      this.emit_empty(this.ending)\n\n    } else if (this[minOffset] < this.length) {\n      this[maxOffset] -= this[minOffset]\n      this.buffer = this.buffer.slice(this[minOffset])\n      this.length = this.buffer.length\n      this[minOffset] = 0\n\n    } else {\n      // Can only occurs if offset was manually incremented\n      this[maxOffset] -= this.length\n      this[minOffset] -= this.length\n      this.buffer = null\n      this.length = 0\n    }\n  }\n\n  return this._done()\n}",
    "ctx": {
      "type": "method",
      "constructor": "Atok",
      "name": "_tokenize",
      "string": "Atok.prototype._tokenize()"
    }
  }
]